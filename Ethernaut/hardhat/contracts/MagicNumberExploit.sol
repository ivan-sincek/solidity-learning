// SPDX-License-Identifier: MIT
pragma solidity 0.8.19;

import "./MagicNumber.sol";

contract MagicNumExploit {
    function run(address _target) external {
        bytes
            memory bytecode = "\x60\x0A\x60\x0C\x60\x00\x39\x60\x0A\x60\x00\xF3\x60\x2A\x60\x00\x52\x60\x20\x60\x00\xF3";
        address solver;
        assembly {
            solver := create(0, add(bytecode, 0x20), mload(bytecode))
        }
        MagicNum(_target).setSolver(solver);
    }
    // more about opcodes at https://ethervm.io
    // --------------------
    // initialization bytecode
    // copy runtime code (10 bytes) to evm memory slot 0
    // execute runtime code from evm memory slot 0
    // --------------------
    // 60  PUSH1 0x0A // 10 bytes (runtime code size)
    // 60  PUSH1 0x0C // 12 bytes (offset / runtime code starting position / initialization code size)
    // 60  PUSH1 0x00 // evm memory slot 0
    // 39  CODECOPY   // copy
    // -----
    // 60  PUSH1 0x0A // 10 bytes
    // 60  PUSH1 0x00 // evm memory slot 0
    // F3  RETURN     // return
    // --------------------
    // runtime bytecode (this bytecode will execute no matter how you interact with the smart contract)
    // store number 42 to contract storage slot 0 (can be any slot)
    // return first 32 bytes (number 42) from contract storage slot 0
    // --------------------
    // 60    PUSH1 0x2A // number 42
    // 60    PUSH1 0x00 // contract storage slot 0
    // 52    MSTORE     // store
    // -----
    // 60    PUSH1 0x20 // 32 bytes
    // 60    PUSH1 0x00 // contract storage slot 0
    // F3    RETURN     // return
}
